/*
 * Copyright (C) 2025 Jacob Wysko
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see https://www.gnu.org/licenses/.
 */

package org.wysko.midis2jam2

import com.jme3.app.Application
import com.jme3.app.SimpleApplication
import com.jme3.app.state.AbstractAppState
import com.jme3.app.state.AppStateManager
import com.jme3.asset.AssetManager
import com.jme3.input.controls.ActionListener
import com.jme3.material.Material
import com.jme3.post.FilterPostProcessor
import com.jme3.post.filters.FadeFilter
import com.jme3.renderer.queue.RenderQueue
import com.jme3.scene.Node
import com.jme3.scene.Spatial
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import org.wysko.kmidi.midi.TimeBasedSequence
import org.wysko.kmidi.midi.event.MetaEvent
import org.wysko.midis2jam2.domain.settings.AppSettings.PlaybackSettings.MidiSpecificationResetSettings.MidiSpecification
import org.wysko.midis2jam2.instrument.Instrument
import org.wysko.midis2jam2.instrument.algorithmic.Collector
import org.wysko.midis2jam2.instrument.algorithmic.InstrumentAssignment
import org.wysko.midis2jam2.instrument.family.percussion.drumset.DrumSet
import org.wysko.midis2jam2.instrument.family.percussion.drumset.DrumSetVisibilityManager
import org.wysko.midis2jam2.starter.ProgressListener
import org.wysko.midis2jam2.starter.configuration.Configuration.AppSettingsConfiguration
import org.wysko.midis2jam2.starter.configuration.Configuration
import org.wysko.midis2jam2.starter.configuration.find
import org.wysko.midis2jam2.util.logger
import org.wysko.midis2jam2.util.minusAssign
import org.wysko.midis2jam2.util.plusAssign
import org.wysko.midis2jam2.util.unaryPlus
import org.wysko.midis2jam2.world.AssetLoader
import org.wysko.midis2jam2.world.CameraController
import org.wysko.midis2jam2.world.DebugTextController
import org.wysko.midis2jam2.world.FakeShadowsController
import org.wysko.midis2jam2.world.HudController
import org.wysko.midis2jam2.world.StandController
import org.wysko.midis2jam2.world.VariableSpeed
import org.wysko.midis2jam2.world.camera.AutoCamController
import org.wysko.midis2jam2.world.camera.CameraAngle
import org.wysko.midis2jam2.world.camera.CameraSpeed
import org.wysko.midis2jam2.world.camera.CameraState
import org.wysko.midis2jam2.world.camera.SlideCameraController
import org.wysko.midis2jam2.world.lyric.LyricController
import org.wysko.midis2jam2.world.modelD
import kotlin.properties.Delegates
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds

/**
 * Controls all aspects of the program. This is the main class of the program.
 *
 * @property sequence The MIDI file to be played.
 * @property fileName The name of the MIDI file.
 * @property configs The configurations to be used.
 */
abstract class Midis2jam2(
    val sequence: TimeBasedSequence,
    open val fileName: String,
    val configs: Collection<Configuration>,
) : AbstractAppState(),
    ActionListener {
    private val _progressListeners: MutableList<ProgressListener> = mutableListOf()

    fun registerProgressListener(listener: ProgressListener) {
        _progressListeners.add(listener)
    }

    /**
     * The root node of the scene.
     */
    val root: Node = Node()

    /**
     * The AssetManager, as provided by the [app].
     */
    val assetManager: AssetManager by lazy { app.assetManager }

    /**
     * If this value is positive, this is the amount of time that has elapsed since the beginning of the MIDI sequence.
     * If this value is negative, the MIDI sequence has not started yet, and is the negation of the time until the
     * sequence starts.
     */
    var time: Duration = (-2.0).seconds

    /** The current state of the camera. */
    var cameraState: CameraState =
        if (configs.find<AppSettingsConfiguration>().appSettings.cameraSettings.isStartAutocamWithSong) {
            CameraState.AUTO_CAM
        } else {
            CameraState.DEVICE_SPECIFIC_CAMERA
        }
        set(value) {
            // Enable/disable controllers based on camera state when value is changed
            setCameraControllersActive(value)

            field = value
        }

    internal fun setCameraControllersActive(value: CameraState) {
        autocamController.isEnabled = value == CameraState.AUTO_CAM
        slideCamController.isEnabled = value == CameraState.SLIDE_CAM
        cameraController.isEnabled = value == CameraState.DEVICE_SPECIFIC_CAMERA

        _isAutoCamActive.value = value == CameraState.AUTO_CAM
        _isSlideCamActive.value = value == CameraState.SLIDE_CAM
    }

    private val _isAutoCamActive = MutableStateFlow(cameraState == CameraState.AUTO_CAM)
    val isAutoCamActive: StateFlow<Boolean>
        get() = _isAutoCamActive

    private val _isSlideCamActive = MutableStateFlow(false)
    val isSlideCamActive: StateFlow<Boolean>
        get() = _isSlideCamActive

    /**
     * The jMonkeyEngine application.
     */
    lateinit var app: SimpleApplication

    /**
     * The AssetLoader for this instance.
     */
    lateinit var assetLoader: AssetLoader

    /**
     * The stage of the scene.
     */
    lateinit var stage: Spatial

    /**
     * The drum set visibility manager.
     */
    lateinit var drumSetVisibilityManager: DrumSetVisibilityManager

    /**
     * The list of collectors.
     */
    protected val collectors: MutableList<Collector<*>> = mutableListOf()

    /**
     * `true` if the sequencer has reached the end of the MIDI file, `false` otherwise.
     */
    protected var isSongFinished: Boolean = false

    /**
     * `true` if the sequence is paused, `false` otherwise.
     */
    protected var paused: Boolean = false

    /**
     * When the MIDI sequence ends, the [time] is recorded to this variable to know when to close the
     * app.
     */
    protected var endTime: Duration by Delegates.notNull()

    /**
     * Used for the fade in of the performance screen.
     */
    protected lateinit var fadeFilter: FadeFilter

    /**
     * The shadow controller.
     */
    var fakeShadowsController: FakeShadowsController? = null

    /**
     * The lyric controller.
     */
    var lyricController: LyricController? = null

    /**
     * The list of instruments.
     */
    lateinit var instruments: List<Instrument>

    /**
     * The stand controller.
     */
    lateinit var standController: StandController

    /**
     * The autocam controller.
     */
    lateinit var autocamController: AutoCamController

    /**
     * The slide-cam controller.
     */
    lateinit var slideCamController: SlideCameraController

    /**
     * The HUD controller.
     */
    lateinit var hudController: HudController

    /**
     * The device-specific camera.
     */
    protected lateinit var cameraController: CameraController

    protected lateinit var debugTextController: DebugTextController
    protected var currentCameraAngle: CameraAngle = CameraAngle.CAMERA_1A
        set(value) {
            cameraState = CameraState.DEVICE_SPECIFIC_CAMERA
            cameraController.moveToCameraAngle(value)
            field = value
        }

    var cameraSpeed: CameraSpeed = CameraSpeed.Normal
        set(value) {
            println("Setting camera speed to ${value.name}")
            (this.cameraController as? VariableSpeed)?.speed = value.speedValue
            field = value
        }

    override fun initialize(stateManager: AppStateManager, app: Application) {
        val settingsConfig = configs.find<AppSettingsConfiguration>().appSettings
        this.app = app as SimpleApplication
        this.assetLoader = AssetLoader(this) { assetName ->
            _progressListeners.onEach { it.onLoadingAsset(assetName) }
        }
        this.stage = with(root) { +modelD("Stage.obj", "Stage.bmp") }.also {
            it.shadowMode = RenderQueue.ShadowMode.Receive
        }
        this.fadeFilter = FadeFilter(0.5f).apply { value = 0f }.also {
            filterPostProcessor()?.addFilter(it)
        }
        this.instruments =
            InstrumentAssignment.assign(this, midiFile = sequence, onLoadingProgress = { progress ->
                _progressListeners.onEach { it.onLoadingProgress(progress) }
            }).onEach {
                // This is a bit of a hack to prevent stuttering when the instrument would first appear
                root += it.root
                root -= it.root
            }
        this.drumSetVisibilityManager =
            DrumSetVisibilityManager(this, instruments.filterIsInstance<DrumSet>())
        this.standController = StandController(this)
        this.lyricController =
            if (settingsConfig.onScreenElementsSettings.lyricsSettings.isShowLyrics) {
                LyricController(
                    this,
                    sequence.smf.tracks
                        .flatMap { it.events }
                        .filterIsInstance<MetaEvent.Lyric>(),
                )
            } else {
                null
            }
        this.autocamController =
            AutoCamController(this, settingsConfig.cameraSettings.isStartAutocamWithSong)
        this.slideCamController = SlideCameraController(this)
        this.debugTextController = DebugTextController(this)
        this.hudController = HudController(this)
        if (settingsConfig.cameraSettings.isStartAutocamWithSong) {
            with(this.app.camera) {
                let {
                    location = it.location
                    rotation = it.rotation
                }
            }
        }
        if (!configs.find<AppSettingsConfiguration>().appSettings.graphicsSettings.shadowsSettings.isUseShadows) {
            fakeShadowsController = FakeShadowsController(this)
        }

        handleResetMessage()


        super.initialize(stateManager, app)
        _progressListeners.onEach { it.onReady() }
    }

    private fun filterPostProcessor() =
        this.app.viewPort.processors.filterIsInstance<FilterPostProcessor>().firstOrNull()

    override fun update(tpf: Float) {
        super.update(tpf)
        val duration = tpf.toDouble().seconds
        debugTextController.tick()
        cameraController.tick(duration)
    }

    /**
     * Handles when a key is pressed, setting the correct camera position.
     *
     * @param name The name of the key-binding pressed.
     * @param isPressed `true` if the key is pressed, `false` otherwise.
     */
    private fun handleCameraSetting(
        name: String,
        isPressed: Boolean,
    ) {
        if (!isPressed) return
        when (name) {
            "autoCam" -> {
                autocamController.trigger()
                cameraState = CameraState.AUTO_CAM
            }

            "slideCam" -> {
                cameraState = CameraState.SLIDE_CAM
            }
        }
        if (name.startsWith("cam")) {
            currentCameraAngle = CameraAngle.handleCameraAngle(currentCameraAngle, name)
            cameraState = CameraState.DEVICE_SPECIFIC_CAMERA
        }
    }

    protected fun handleResetMessage() {
        val config =
            configs.find<AppSettingsConfiguration>().appSettings.playbackSettings.midiSpecificationResetSettings
        if (config.isSendSpecificationResetMessage) {
            sendResetMessage(config.midiSpecification)
            logger().debug("Sent ${config.midiSpecification} reset message to MIDI device")
        }
    }

    abstract fun sendResetMessage(midiSpecification: MidiSpecification)

    /**
     * Called when an input to which this listener is registered to is invoked.
     *
     * @param name The name of the mapping that was invoked.
     * @param isPressed `true` if the action is "pressed", `false` otherwise
     * @param tpf The amount of time that has passed since the last frame, in seconds.
     */
    override fun onAction(
        name: String,
        isPressed: Boolean,
        tpf: Float,
    ) {
        handleCameraSetting(name, isPressed)
        if (isPressed) {
            when (name) {
                "exit" -> exit()
                "debug" -> debugTextController.toggle()
                "seek_forward" -> seek(time + 10.seconds)
                "seek_backward" -> seek((time - 10.seconds).coerceAtLeast(0.seconds))
                "play/pause" -> togglePause()
            }
        }
    }

    /** Seeks to a given point in time. */
    abstract fun seek(time: Duration)

    /** Exits the application. */
    abstract fun exit()

    /** Pauses or resumes the application, depending on the current [paused] state. */
    protected open fun togglePause() {
        paused = !paused
    }

    /** Loads and returns a reflective material with the specified [texture] at a default brightness. */
    fun reflectiveMaterial(texture: String): Material = assetLoader.reflectiveMaterial(texture)

    /** Loads and returns an unshaded material with the specified [texture]. */
    fun diffuseMaterial(texture: String): Material = assetLoader.diffuseMaterial(texture)

    /**
     * Registers a [collector] to be updated when the time is advanced.
     *
     * @param collector The collector to be registered.
     */
    fun registerCollector(collector: Collector<*>) {
        collectors += collector
    }

    override fun stateDetached(stateManager: AppStateManager?) {
        super.stateDetached(stateManager)
        filterPostProcessor()?.removeFilter(fadeFilter)
    }
}
